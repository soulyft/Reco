===== ./ProductResponse.swift =====
//
//  ProductResponse.swift
//  Reco
//
//  Created by Corey Lofthus on 12/16/24.
//

import Foundation

struct ProductResponse: Decodable {
    let name: String
    let price: Double
    let summary: String
    let imageURL: String
    let affiliateLink: String
}

struct FunctionCallArguments: Decodable {
    let query: String
    let userProfile: UserProfileArguments

    struct UserProfileArguments: Decodable {
        let budgetSensitivity: Double
        let brandLoyalty: Double
    }
}

enum APIClientError: Error, LocalizedError {
    case invalidResponse
    case decodingError
    case serverError(Int, String)
    case missingAPIKey
    case unknownError(Error)
    
    var errorDescription: String? {
        switch self {
        case .invalidResponse:
            return "The server returned an invalid response."
        case .decodingError:
            return "Failed to decode the server response."
        case .serverError(let code, let body):
            return "Server error \(code): \(body)"
        case .missingAPIKey:
            return "API key is missing. Please check your configuration."
        case .unknownError(let error):
            return "An unknown error occurred: \(error.localizedDescription)"
        }
    }
}

class APIClient {
    func fetchRecommendation(for query: String, userProfile: UserProfile) async throws -> ProductResponse {
        let url = URL(string: "https://api.openai.com/v1/chat/completions")!
        let requestBody: [String: Any] = [
            "model": "gpt-4o-mini",
            "messages": [
                ["role": "system", "content": """
                You are a product recommendation assistant. 
                Respond **only** with JSON in this format:
                {"name": "Product Name", "price": 29.99, "summary": "Description", "imageURL": "https://image.com", "affiliateLink": "https://link.com"}
                use budget sensitivity to stay close to the range requested on a sliding scale from 0-1
                use brand loyalty to suggest well known brands on a sliding scale from 0-1
                """],
                ["role": "user", "content": "Query: \(query), Budget: \(userProfile.budgetSensitivity), Brand Loyalty: \(userProfile.brandLoyalty)"]
            ],
            "temperature": 0.7,
            "max_tokens": 150
        ]

        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("Bearer \(loadAPIKey() ?? "")", forHTTPHeaderField: "Authorization")
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.httpBody = try JSONSerialization.data(withJSONObject: requestBody)

        let (data, response) = try await URLSession.shared.data(for: request)

        // Ensure the response is an HTTPURLResponse and check the status code
        guard let httpResponse = response as? HTTPURLResponse else {
            throw APIClientError.invalidResponse
        }

        guard (200...299).contains(httpResponse.statusCode) else {
            let responseBody = String(data: data, encoding: .utf8) ?? "No response body"
            throw APIClientError.serverError(httpResponse.statusCode, responseBody)
        }

        // Log raw response for debugging
        if let responseBody = String(data: data, encoding: .utf8) {
            print("Raw Response Body: \(responseBody)")
        }

        // Decode the OpenAI API response
        let apiResponse = try JSONDecoder().decode(OpenAIChatResponse.self, from: data)

        guard let messageContent = apiResponse.choices.first?.message.content else {
            throw APIClientError.invalidResponse
        }

        // Decode message content into ProductResponse
        let productResponse = try JSONDecoder().decode(ProductResponse.self, from: Data(messageContent.utf8))
        return productResponse
    }

    private func loadAPIKey() -> String? {
        guard let url = Bundle.main.url(forResource: "Secrets", withExtension: "plist"),
              let data = try? Data(contentsOf: url),
              let plist = try? PropertyListSerialization.propertyList(from: data, format: nil) as? [String: Any] else {
            return nil
        }
        return plist["OPENAI_API_KEY"] as? String
    }
}

// Define the structures to match the OpenAI API response
struct OpenAIChatResponse: Decodable {
    let choices: [Choice]
}

struct Choice: Decodable {
    let message: Message
}

struct Message: Decodable {
    let role: String
    let content: String?
}

===== ./Models/Item.swift =====
//
//  Item.swift
//  Reco
//
//  Created by Corey Lofthus on 12/16/24.
//

import Foundation
import SwiftData

@Model
final class Item {
    var timestamp: Date
    
    init(timestamp: Date) {
        self.timestamp = timestamp
    }
}

===== ./Models/UserProfile.swift =====
//
//  UserProfile.swift
//  Reco
//
//  Created by Corey Lofthus on 12/16/24.
//

import SwiftUI
import SwiftData

@Model
class UserProfile {
    @Attribute(.unique) var id: UUID = UUID() // Ensures uniqueness
    var name: String = "User"
    var budgetSensitivity: Double = 0.5
    var brandLoyalty: Double = 0.5

    init(name: String = "User", budgetSensitivity: Double = 0.5, brandLoyalty: Double = 0.5) {
        self.name = name
        self.budgetSensitivity = budgetSensitivity
        self.brandLoyalty = brandLoyalty
    }
}

===== ./Models/MainViewModel.swift =====
//
//  MainViewModel.swift
//  Reco
//
//  Created by Corey Lofthus on 12/16/24.
//

import SwiftUI
import SwiftData
import Observation

@Observable
@MainActor
class MainViewModel {
    var userQuery: String = ""
    var currentRecommendation: Recommendation?
    var isLoading = false
    var errorMessage: String?
    var selectedTab: Int = 1
    
    var context: ModelContext
    private let apiClient = APIClient()
    
    init(context: ModelContext) {
        self.context = context
        ensureUserProfileExists()
    }
    
    private func ensureUserProfileExists() {
        do {
            let profiles = try context.fetch(FetchDescriptor<UserProfile>())
            if profiles.isEmpty {
                let profile = UserProfile()
                context.insert(profile)
                try context.save()
            }
        } catch {
            print("Error ensuring user profile exists: \(error)")
        }
    }

    private var userProfile: UserProfile? {
        do {
            return try context.fetch(FetchDescriptor<UserProfile>()).first
        } catch {
            print("Error fetching user profile: \(error)")
            return nil
        }
    }
    
    // Fetch new recommendation
    func getRecommendation() {
        Task {
            guard !userQuery.isEmpty else {
                print("User query is empty.")
                return
            }
            
            isLoading = true
            errorMessage = nil
            
            do {
                guard let profile = userProfile else {
                    errorMessage = "User profile not found."
                    print("Error: User profile not found.")
                    return
                }
                
                let product = try await apiClient.fetchRecommendation(for: userQuery, userProfile: profile)
                print("API returned product: \(product)")
                
                // Save recommendation
                let reco = Recommendation(name: product.name,
                                          price: product.price,
                                          summary: product.summary,
                                          imageURL: product.imageURL,
                                          affiliateLink: product.affiliateLink)
                context.insert(reco)
                try context.save()
                
                currentRecommendation = reco
                print("Recommendation saved and updated.")
            } catch {
                errorMessage = "Failed to get recommendation: \(error.localizedDescription)"
                print("Error during API call: \(error.localizedDescription)")
            }
            userQuery = ""
            isLoading = false
        }
    }

    // Refine current recommendation
    func iterateRecommendation() {
        Task {
            guard let currentReco = currentRecommendation else {
                errorMessage = "No recommendation to iterate on."
                return
            }
            
            isLoading = true
            errorMessage = nil
            
            do {
                guard let profile = userProfile else {
                    errorMessage = "User profile not found."
                    return
                }
                
                let newQuery = "return a new product \(userQuery) refined from \(currentReco.name) at \(currentReco.price): \(currentReco.summary)"
                print("Iterating with query: \(newQuery)")
                
                let product = try await apiClient.fetchRecommendation(for: newQuery, userProfile: profile)
                print("API returned updated product: \(product)")
                
                let reco = Recommendation(name: product.name,
                                          price: product.price,
                                          summary: product.summary,
                                          imageURL: product.imageURL,
                                          affiliateLink: product.affiliateLink)
                
                context.insert(reco)
                try context.save()
                currentRecommendation = reco
                print("Recommendation updated with new iteration.")
            } catch {
                errorMessage = "Failed to iterate recommendation: \(error.localizedDescription)"
                print("Error during iteration: \(error.localizedDescription)")
            }
            userQuery = ""
            isLoading = false
        }
    }

    // Clear recommendation
    func clearRecommendation() {
        currentRecommendation = nil
        userQuery = ""
        print("Recommendation cleared.")
    }
}

===== ./Models/Recommendation.swift =====
//
//  Recommendation.swift
//  Reco
//
//  Created by Corey Lofthus on 12/16/24.
//

import SwiftUI
import SwiftData

@Model
class Recommendation {
    var id: UUID
    var name: String
    var price: Double
    var summary: String
    var imageURL: String
    var affiliateLink: String
    var date: Date
    
    init(id: UUID = UUID(), name: String, price: Double, summary: String, imageURL: String, affiliateLink: String, date: Date = Date()) {
        self.id = id
        self.name = name
        self.price = price
        self.summary = summary
        self.imageURL = imageURL
        self.affiliateLink = affiliateLink
        self.date = date
    }
}

===== ./RecoApp.swift =====
//
//  RecoApp.swift
//  Reco
//
//  Created by Corey Lofthus on 12/16/24.
//

import SwiftUI
import SwiftData

@main
struct MyRecoAppApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
        .modelContainer(for: [UserProfile.self, Recommendation.self])
        
    }
    
}

===== ./Views/ProductCard.swift =====
//
//  ProductCard.swift
//  Reco
//
//  Created by Corey Lofthus on 12/16/24.
//

import SwiftUI

struct ProductCard: View {
    let recommendation: Recommendation
    @Binding var isCompact: Bool 
    
    var body: some View {
        VStack {
          
            if isCompact {
                // Compact Layout: Image on the left
                HStack(alignment: .top, spacing: 12) {
                    productImage
                    productDetails
                    Spacer()
                }
                .padding(16)
                
            } else {
                // Full-size Layout: Image on top
                VStack(alignment: .center, spacing: 12) {
                    productImage
                    productDetails
                }
                .padding(20)
            }
            
        }
        .background(Color(UIColor.secondarySystemBackground))
        .cornerRadius(12)
        .shadow(color: Color.black.opacity(0.1), radius: 2, x: 0, y: 2)
    }
    
    // MARK: - Product Image
    @State private var showProgressView: Bool = true
    @State private var cachedImage: Image? = nil

    private var productImage: some View {
        AsyncImage(url: URL(string: recommendation.imageURL)) { phase in
            switch phase {
            case .empty:
                ZStack {
                    if showProgressView {
                        ProgressView() // Show progress view initially
                            .transition(.opacity)
                            .frame(height: isCompact ? 80 : 180)
                    } else {
                        Image(systemName: "photo.artframe") // Default fallback icon
                            .resizable()
                            .scaledToFit()
                            .frame(height: isCompact ? 80 : 180)
                            .foregroundColor(.gray.opacity(0.5))
                    }
                }
                .onAppear {
                    // Turn off the progress view after 3 seconds
                    DispatchQueue.main.asyncAfter(deadline: .now() + 3) {
                        withAnimation {
                            showProgressView = false
                        }
                    }
                }
                
            case .success(let image):
                image
                    .resizable()
                    .scaledToFit()
                    .frame(height: isCompact ? 80 : 180)
                    .clipShape(RoundedRectangle(cornerRadius: 8))
                    .shadow(radius: isCompact ? 1 : 2)
                    .onAppear {
                        cachedImage = image // Cache SwiftUI Image directly
                    }
            
            case .failure:
                Image(systemName: "photo.artframe")
                    .resizable()
                    .scaledToFit()
                    .frame(height: isCompact ? 80 : 180)
                    .foregroundColor(.gray.opacity(0.5))
                
            @unknown default:
                EmptyView()
            }
        }
    }
    
    // MARK: - Product Details
    private var productDetails: some View {
        VStack(alignment: .leading, spacing: isCompact ? 4 : 8) {
            Text(recommendation.name)
                .font(isCompact ? .headline : .title2)
                .fontWeight(.bold)
                .lineLimit(2)
            
            Text("$\(recommendation.price, specifier: "%.2f")")
                .font(isCompact ? .headline : .title3)
                .fontDesign(.monospaced)
                .fontWeight(.semibold)
                .foregroundColor(.green)
            
            if !isCompact {
                Text(recommendation.summary)
                    .font(.subheadline)
                    .foregroundColor(.secondary)
                    .lineLimit(3)
                Link(destination: URL(string: recommendation.affiliateLink) ?? URL(string: "https://amazon.com")!) {
                    Text("Buy Now")
                        .frame(maxWidth: .infinity)
                        .padding()
                        .background(Color.blue)
                        .foregroundColor(.white)
                        .cornerRadius(8)
                        .shadow(radius: 2)
                        .padding(.top)
                }
            }

            
        }
    }
}

===== ./Views/UserProfileView.swift =====
//
//  UserProfileView.swift
//  Reco
//
//  Created by Corey Lofthus on 12/16/24.
//

import SwiftUI
import SwiftData

struct UserProfileView: View {
    @Query private var userProfile: [UserProfile]
    @Environment(\.modelContext) private var context

    @State private var editedName: String = ""

    var body: some View {
        let profile = userProfile.first ?? createAndSaveDefaultProfile()

        Form {
            Section(header: Text("Personal Information")) {
                TextField("Name", text: $editedName, onCommit: {
                    profile.name = editedName
                    saveProfile()
                })
                .onAppear {
                    editedName = profile.name
                }
                .font(.headline)
            }

            Section(header: Text("Preferences")) {
                ForEach(UserFactor.allCases, id: \.self) { factor in
                    FactorSliderView(
                        title: factor.rawValue,
                        value: getBinding(for: factor, profile: profile)
                    )
                }
            }
        }
        .navigationTitle("User Profile")
        .navigationBarTitleDisplayMode(.inline)
    }

    // MARK: - Helper Methods
    
    private func createAndSaveDefaultProfile() -> UserProfile {
        let newProfile = UserProfile()
        context.insert(newProfile)
        saveProfile()
        return newProfile
    }

    private func saveProfile() {
        do {
            try context.save()
        } catch {
            print("Failed to save profile: \(error.localizedDescription)")
        }
    }

    private func getBinding(for factor: UserFactor, profile: UserProfile) -> Binding<Double> {
        switch factor {
        case .budgetSensitivity:
            return Binding(
                get: { profile.budgetSensitivity },
                set: { newValue in
                    profile.budgetSensitivity = newValue
                    saveProfile()
                }
            )
        case .brandLoyalty:
            return Binding(
                get: { profile.brandLoyalty },
                set: { newValue in
                    profile.brandLoyalty = newValue
                    saveProfile()
                }
            )
        }
    }
}

// MARK: - Subviews

struct FactorSliderView: View {
    let title: String
    @Binding var value: Double

    var body: some View {
        VStack(alignment: .leading) {
            Text("\(title): \(Int(value * 100))%")
            Slider(value: $value, in: 0...1, step: 0.01)
        }
        .padding(.vertical, 4)
    }
}

// MARK: - Enums

enum UserFactor: String, CaseIterable {
    case budgetSensitivity = "Budget Sensitivity"
    case brandLoyalty = "Brand Loyalty"
}

===== ./Views/RecoView.swift =====
//
//  RecoView.swift
//  Reco
//
//  Created by Corey Lofthus on 12/16/24.
//

import SwiftUI
import SwiftData

struct RecoView: View {
    @Bindable var viewModel: MainViewModel
    @FocusState private var isTextFieldFocused: Bool // Track focus state
    @State var isCompact: Bool = false
    @Environment(\.colorScheme) var colorScheme
    @State var isCardSheetPresented: Bool = false
    
    var body: some View {
        VStack {
            Spacer()
            
            // Display recommendation if available
            if let reco = viewModel.currentRecommendation {
                ProductCard(recommendation: reco,
                            isCompact: $isCompact)
                    .padding()
                    .onTapGesture {
                        if !isCompact {
                            isCardSheetPresented = true
                        }
                    }
                    .sheet(isPresented: $isCardSheetPresented) {
                        VStack{
                            ProductCard(recommendation: reco,
                                        isCompact: $isCompact)
                            Spacer()
                            Text("user reviews and more information")
                            Spacer()
                        }
                    }
            }
            
            // Show loading spinner
            if viewModel.isLoading {
                ProgressView("Loading reco...")
            }
            
            Spacer()
            
            // Input text field
            TextField("What are you looking for?", text: $viewModel.userQuery)
                .textFieldStyle(RoundedBorderTextFieldStyle())
                .padding(.horizontal)
                .focused($isTextFieldFocused) // Track focus state
            
            // Buttons for updating and clearing
            HStack {
                if viewModel.currentRecommendation != nil {
                    Button(action: {
                        viewModel.iterateRecommendation()
                        isTextFieldFocused = false // Dismiss keyboard
                    }) {
                        Text("Update Reco")
                            .padding()
                            .frame(maxWidth: .infinity)
                            .background(Color.blue)
                            .foregroundColor(.white)
                            .cornerRadius(8)
                    }
                    
                    Button(action: {
                        viewModel.clearRecommendation()
                        viewModel.userQuery = "" // Clear text input
                        isTextFieldFocused = false // Dismiss keyboard
                        
                    }) {
                        Text("Clear Reco")
                            .padding()
                            .frame(maxWidth: .infinity)
                            .background(Color.red)
                            .foregroundColor(.white)
                            .cornerRadius(8)
                    }
                } else if !viewModel.isLoading {
                    Button(action: {
                        viewModel.getRecommendation()
                        isTextFieldFocused = false // Dismiss keyboard
                    }) {
                        Text("Get Reco")
                            .padding()
                            .frame(maxWidth: .infinity)
                            .background(Color.blue)
                            .foregroundColor(.white)
                            .cornerRadius(8)
                    }
                }
            }
            .padding()
            
            // Show error message if any
            if let error = viewModel.errorMessage {
                Text(error)
                    .foregroundColor(.red)
                    .padding()
            }
            Spacer()
        }
        .background(content: {
            meshGradientBackground // Gradient background
                .colorInvertIfDarkMode(colorScheme: colorScheme)
        })
        .onTapGesture {
            isTextFieldFocused = false // Dismiss keyboard
        }
        .onChange(of: isTextFieldFocused) { oldValue, newValue in
            withAnimation(.bouncy) {
                isCompact = isTextFieldFocused
            }
          
        }
    }
    
    // MARK: - Mesh Gradient Background
    private var meshGradientBackground: some View {
        Rectangle()
            .fill(
                MeshGradient(
                    width: 3,
                    height: 3,
                    points: [
                        SIMD2<Float>(0, 0), SIMD2<Float>(0.5, 0), SIMD2<Float>(1, 0),
                        SIMD2<Float>(0, 0.5), SIMD2<Float>(0.5, 0.5), SIMD2<Float>(1, 0.5),
                        SIMD2<Float>(0, 1), SIMD2<Float>(0.5, 1), SIMD2<Float>(1, 1)
                    ],
                    colors: [
                        Color(red: 1, green: 0.85, blue: 0.7), // Soft warm color
                        Color(red: 0.95, green: 0.95, blue: 1), // Neutral
                        Color(red: 0.7, green: 0.85, blue: 1), // Soft cool color
                        Color(red: 0.9, green: 0.75, blue: 1), // Subtle purple
                        Color.white,
                        Color(red: 0.8, green: 1, blue: 0.85), // Subtle green
                        Color.white,
                        Color(red: 1, green: 0.9, blue: 0.8),
                        Color(red: 0.75, green: 0.85, blue: 1)
                    ],
                    background: Color.white, // Fallback
                    smoothsColors: true
                )
            )
            .ignoresSafeArea()
    }
}

extension View {
    func colorInvertIfDarkMode(colorScheme: ColorScheme) -> some View {
        self.modifier(ColorInvertModifier(shouldInvert: colorScheme == .dark))
    }
}

struct ColorInvertModifier: ViewModifier {
    let shouldInvert: Bool
    
    func body(content: Content) -> some View {
        if shouldInvert {
            content
                .colorInvert() // Apply color inversion
        } else {
            content
        }
    }
}

===== ./Views/HistoryView.swift =====
import SwiftUI
import SwiftData

struct HistoryView: View {
    @Query(sort: \Recommendation.date, order: .reverse) var recommendations: [Recommendation]
    @Environment(\.modelContext) private var modelContext
    @Environment(MainViewModel.self) var viewModel
    
    var body: some View {
        NavigationView {
            List {
                ForEach(recommendations) { reco in
                    VStack(alignment: .leading) {
                        Text(reco.name)
                            .font(.headline)
                        Text("$\(reco.price, specifier: "%.2f") - \(reco.summary)")
                            .font(.subheadline)
                            .foregroundColor(.secondary)
                    }
                    .onTapGesture {
                        handleRecommendationTap(recommendation: reco)
                    }
                }
                .onDelete(perform: deleteRecommendation) // Add delete functionality
            }
            .navigationTitle("History")
            .toolbar {
                ToolbarItem(placement: .topBarTrailing) {
                    Button("Clear All") {
                        clearHistory()
                    }
                }
            }
        }
    }
    // Handle when a recommendation is tapped
    private func handleRecommendationTap(recommendation: Recommendation) {
        // Set the tapped recommendation as the current recommendation
        viewModel.currentRecommendation = recommendation
        viewModel.selectedTab = 1

    }
    // Function to delete individual recommendations
    private func deleteRecommendation(at offsets: IndexSet) {
        for index in offsets {
            modelContext.delete(recommendations[index])
        }
    }
    
    // Function to clear the entire history
    private func clearHistory() {
        for reco in recommendations {
            modelContext.delete(reco)
        }
    }
}

===== ./Views/ContentView.swift =====
//
//  ContentView.swift
//  Reco
//
//  Created by Corey Lofthus on 12/16/24.
//

import SwiftUI
import SwiftData


struct ContentView: View {
    @Environment(\.modelContext) var context
  
    @State private var viewModel: MainViewModel
    
    init() {
            // Use a placeholder value; actual context will be injected in `onAppear`
            _viewModel = State(initialValue: MainViewModel(context: ModelContext.previewContext))
        }
    

        
    var body: some View {
          TabView(selection: $viewModel.selectedTab) {
              UserProfileView()
                  .tabItem {
                      Label("Profile", systemImage: "person.crop.circle")
                  }
                  .tag(0) // Tag for identifying this tab
              
                  RecoView(viewModel: viewModel)
                      .tabItem {
                          Label("Home", systemImage: "house")
                      }
                      .tag(1) // Tag for identifying this tab
              
              HistoryView()
                  .tabItem {
                      Label("History", systemImage: "clock")
                  }
                  .tag(2) // Tag for identifying this tab
          }
          .onAppear {
              // Update the context on viewModel once environment is available
              if viewModel.context !== context {
                  viewModel.context = context
              }
          }
          .environment(viewModel)
      }

  }

extension ModelContext {
    static var previewContext: ModelContext {
        let container = try! ModelContainer(for: UserProfile.self, Recommendation.self)
        return ModelContext(container)
    }
}
#Preview {
    ContentView()
        .modelContainer(for: [UserProfile.self, Recommendation.self])
}

